jak funguje jednotlivÃ© metody?
__init__(self, filepath)
inicializuje objekt s cestou k souboru (filepath).
nastavÃ­ logger pro zaznamenÃ¡vÃ¡nÃ­ udÃ¡lostÃ­.
load_data(self)
pokud soubor neexistuje, vrÃ¡tÃ­ vÃ½chozÃ­ hodnotu:
python
Copy
Edit
{"accounts": {}, "next_account": 10000}
accounts: slovnÃ­k ÃºÄtÅ¯ (zatÃ­m prÃ¡zdnÃ½).
next_account: ÄÃ­slovÃ¡nÃ­ novÃ½ch ÃºÄtÅ¯ zaÄne od 10000.
pokud soubor existuje, pokusÃ­ se naÄÃ­st data.
pokud se pÅ™i ÄtenÃ­ objevÃ­ chyba (napÅ™. neplatnÃ½ json), zaloguje chybu a vrÃ¡tÃ­ vÃ½chozÃ­ hodnotu.
save_data(self, data)
uloÅ¾Ã­ data do souboru ve formÃ¡tu json s odsazenÃ­m (indent=4 pro pÅ™ehlednost).
pokud dojde k chybÄ› (napÅ™. problÃ©m se zÃ¡pisem), zaloguje ji.
jak je to pouÅ¾itelnÃ©?
python
Copy
Edit
storage = Storage("bank_data.json")
data = storage.load_data()

# manipulace s daty
data["accounts"]["10000"] = {"balance": 500}

storage.save_data(data)
tento kÃ³d:

naÄte data (nebo vytvoÅ™Ã­ novÃ¡).
pÅ™idÃ¡ ÃºÄet s ÄÃ­slem 10000 a zÅ¯statkem 500.
uloÅ¾Ã­ zpÄ›t do souboru.
co by se dalo vylepÅ¡it?
zÃ¡mek souboru pÅ™i zÃ¡pisu (aby se pÅ™edeÅ¡lo soubÄ›Å¾nÃ½m zÃ¡pisÅ¯m).
validace struktury json po naÄtenÃ­ (napÅ™. kontrola, zda accounts je opravdu slovnÃ­k).

VysvÄ›tlivky:
âœ… zÃ¡mek souboru pÅ™i zÃ¡pisu (pomocÃ­ threading.Lock())
âœ… validaci datovÃ© struktury po naÄtenÃ­ (kontrola, zda je sprÃ¡vnÄ› formÃ¡tovanÃ¡)
âœ… lepÅ¡Ã­ logovÃ¡nÃ­ chyb pro snadnÄ›jÅ¡Ã­ ladÄ›nÃ­

python
Copy
Edit
import json
import os
import logging
import threading

class Storage:
    def __init__(self, filepath):
        self.filepath = filepath
        self.logger = logging.getLogger("Storage")
        self.lock = threading.Lock()  # ZÃ¡mek pro bezpeÄnÃ½ zÃ¡pis

    def load_data(self):
        """NaÄte data z JSON souboru. Pokud soubor neexistuje nebo je poÅ¡kozenÃ½, vrÃ¡tÃ­ vÃ½chozÃ­ hodnoty."""
        if not os.path.exists(self.filepath):
            self.logger.info("DatovÃ½ soubor neexistuje, inicializuji novÃ¡ data.")
            return self.default_data()

        try:
            with open(self.filepath, "r", encoding="utf-8") as f:
                data = json.load(f)

            # OvÄ›Å™enÃ­ struktury dat
            if not self.validate_data(data):
                self.logger.error("NeplatnÃ¡ struktura dat, inicializuji vÃ½chozÃ­ hodnoty.")
                return self.default_data()

            return data
        except (json.JSONDecodeError, IOError) as e:
            self.logger.error(f"Chyba pÅ™i naÄÃ­tÃ¡nÃ­ dat: {e}")
            return self.default_data()

    def save_data(self, data):
        """BezpeÄnÄ› uloÅ¾Ã­ data do JSON souboru s vyuÅ¾itÃ­m zÃ¡mku."""
        with self.lock:
            try:
                with open(self.filepath, "w", encoding="utf-8") as f:
                    json.dump(data, f, ensure_ascii=False, indent=4)
                self.logger.info("Data byla ÃºspÄ›Å¡nÄ› uloÅ¾ena.")
            except IOError as e:
                self.logger.error(f"Chyba pÅ™i uklÃ¡dÃ¡nÃ­ dat: {e}")

    def default_data(self):
        """VrÃ¡tÃ­ vÃ½chozÃ­ strukturu dat."""
        return {"accounts": {}, "next_account": 10000}

    def validate_data(self, data):
        """Zkontroluje, zda majÃ­ naÄtenÃ¡ data sprÃ¡vnou strukturu."""
        return (
            isinstance(data, dict) and
            "accounts" in data and isinstance(data["accounts"], dict) and
            "next_account" in data and isinstance(data["next_account"], int)
        )
co je vylepÅ¡eno?
âœ… ochrana pÅ™ed soubÄ›Å¾nÃ½m zÃ¡pisem â†’ pokud vÃ­ce vlÃ¡ken chce zapisovat souÄasnÄ›, pouÅ¾ije se threading.Lock()
âœ… ochrana pÅ™ed poÅ¡kozenÃ½m souborem â†’ pokud je json nevalidnÃ­, zaloguje se chyba a pouÅ¾ijÃ­ se vÃ½chozÃ­ hodnoty
âœ… validace dat â†’ pokud jsou po naÄtenÃ­ data v nesprÃ¡vnÃ©m formÃ¡tu, pouÅ¾ije se vÃ½chozÃ­ struktura
âœ… lepÅ¡Ã­ logovÃ¡nÃ­ â†’ vÅ¡echny chyby jsou zalogovÃ¡ny pro snadnÄ›jÅ¡Ã­ ladÄ›nÃ­

mÃ¡Å¡ k tomu nÄ›jakÃ© dotazy nebo Ãºpravy? ğŸ˜Š
